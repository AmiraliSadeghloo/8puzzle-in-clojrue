<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="73f5f1ee-b41e-4ef2-8e37-759a5ab5d8b9" name="Default Changelist" comment="" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="ProjectId" id="1dY3njKef652u6rcjHDqgp12uUh" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showExcludedFiles" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="aspect.path.notification.shown" value="true" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$/../ultimateeightpuzzle" />
  </component>
  <component name="ReplState" timestamp="1592726412679">{:repl-history {:ide [], :local [{:command &quot;(testtest)&quot;, :offset 10, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;testtest&quot;, :offset 8, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(:hi testtest)&quot;, :offset 14, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(:hii testtest)&quot;, :offset 15, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(max 1 2 3)&quot;, :offset 11, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(max 1 2 nil 3)&quot;, :offset 15, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(max 1 2 false 3)&quot;, :offset 17, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(max 1 2 -1 3)&quot;, :offset 14, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(case [1 2]\n  [1 2] 3\n  [2 3] 4)&quot;, :offset 32, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(case [1 2]\n  (= 1(first [1 2])) 3\n  [2 3] 4)&quot;, :offset 45, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(def something {:a 1 :b 2 :c 3 :d false :e \&quot;any\&quot;})&quot;, :offset 50, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(def max (key (apply max-key val something)))&quot;, :offset 45, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(def something {:a 1 :b 2 :c 3 :d 2 :e -2})&quot;, :offset 43, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(def maxy (key (apply max-key val something)))&quot;, :offset 46, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(key (apply max-key val something))&quot;, :offset 35, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(def something {:a 1 :b 2 :c 3 :d false :e -2})&quot;, :offset 47, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(key (apply max-key val (filter #(not= false val) something)))&quot;, :offset 62, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(filter #(not= false val) something)&quot;, :offset 36, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn filter-by-val-1\n  [m]\n  (into {} (filter (fn [[k v]] (false v))\n                   m)))&quot;, :offset 93, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn filter-by-val-2 #(and (not (nil? %))\n                       (not (zero? %)))\n                 {:x 1 :y nil})&quot;, :offset 114, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn filter-by-val-1\n  [m]\n  (into {} (filter (fn [[k v]] (= v false))\n                   m)))&quot;, :offset 95, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn filter-by-val-1\n  [m]\n  (into {} (filter (fn [[k v]] (not= v false))\n                   m)))&quot;, :offset 98, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(filter-by-val-1 something)&quot;, :offset 27, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(def testt [])&quot;, :offset 14, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(println testt)&quot;, :offset 15, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(move-reverse :up)&quot;, :offset 18, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn move-reverse [move]\n  (case move\n    :up :down\n    :right :left\n    :left :right\n    :down :up\n    nil))&quot;, :offset 110, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(move-reverse [])&quot;, :offset 17, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn swap-right                                            ;;ok if reaches border/ puts nil\n  [x [i1 j1]]\n  (let [f (get-in x [i1 j1])\n        q (assoc-in x [i1 j1] (get-in x [i1 (+ 1 j1)]))\n        s (assoc-in q [i1 (+ 1 j1)] f)]\n    s))&quot;, :offset 239, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(swap-right [[1 2 3] [4 5 6] [0 7 8]] [2 0])&quot;, :offset 44, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(zero-finder [[1 2 3] [4 5 6] [0 7 8]])&quot;, :offset 39, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(:zero (zero-finder [[1 2 3] [4 5 6] [0 7 8]]))&quot;, :offset 47, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(swap-right [[1 2 3] [4 5 6] [0 7 8]] (:zero (zero-finder [[1 2 3] [4 5 6] [0 7 8]])))&quot;, :offset 86, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn filter-false-val\n  [m]\n  (into {} (filter (fn [[k v]] (not= v false))\n                   m)))&quot;, :offset 99, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn main [init]\n  (if (solvable? init)\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        (if (or (= ideal (:vector node))\n                (&gt; i 33))\n          (:history node)\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (:history node))))\n                                  false\n                                  (swap-right (:vector node) zero))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (:history node))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (:history node))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (:history node))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n              (let [moves-cost {:right (if (or (= :right (move-reverse (last (:history node))))\n                                               (= false (:right moves)))\n                                         false\n                                         (reduce + (map count-same-with-ideal (:right moves))))\n                                :left  (if (or (= :left (move-reverse (last (:history node))))\n                                               (= false (:left moves)))\n                                         false\n                                         (reduce + (map count-same-with-ideal (:left moves))))\n                                :up    (if (or (= :up (move-reverse (last (:history node))))\n                                               (= false (:up moves)))\n                                         false\n                                         (reduce + (map count-same-with-ideal (:up moves))))\n                                :down  (if (or (= :down (move-reverse (last (:history node))))\n                                               (= false (:down moves)))\n                                         false\n                                         (reduce + (map count-same-with-ideal (:down moves))))\n                                }]\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves-cost next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})))))))))))&quot;, :offset 2674, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn solvable2 [x]\n  (loop [counts [] xs x]\n    (if (seq xs)\n      (let [head (first xs)\n            tail (rest xs)\n            counter (fn [accum curr] (if (&gt; curr head) (inc accum) accum))]\n        (recur (conj counts (reduce counter 0 tail)) tail))\n      counts)))&quot;, :offset 268, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(solvable2 [1 2 3 4 5 6 7 8 0])&quot;, :offset 31, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(reduce + (solvable2 [1 2 3 4 5 6 7 8 0]))&quot;, :offset 42, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(true? (= 0(mod (reduce + (solvable2 [1 2 3 4 5 6 7 8 0])) 2)))&quot;, :offset 63, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(true? (= 0(mod (reduce + (solvable2 [1 2 3 4 5 6 7 0 8])) 2)))&quot;, :offset 63, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(true? (= 0(mod (reduce + (solvable2 [1 2 3 4 5 6 0 7 8])) 2)))&quot;, :offset 63, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(solvable2 [1 2 3 4 5 6 0 7 8])&quot;, :offset 31, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(true? (odd? (reduce + (solvable2 [1 2 3 4 5 6 7 8 0]))))&quot;, :offset 57, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(odd? (reduce + (solvable2 [1 2 3 4 5 6 7 8])))&quot;, :offset 47, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(odd? (reduce + (solvable2 [1 2 3 4 5 6 8 7])))&quot;, :offset 47, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(odd? (reduce + (solvable2 [1 2 3 4 5 8 6 7])))&quot;, :offset 47, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn solvable2 [x]\n  (let [removed-zero (filter #(= 0 %) x)]\n  (loop [counts [] xs removed-zero]\n    (if (seq xs)\n      (let [head (first xs)\n            tail (rest xs)\n            counter (fn [accum curr] (if (&gt; curr head) (inc accum) accum))]\n        (recur (conj counts (reduce counter 0 tail)) tail))\n      counts))))&quot;, :offset 322, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(odd? (reduce + (solvable2 [1 2 3 4 5 6 7 8 0])))&quot;, :offset 49, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(filter #(= 0 %) [1 2 3 4 5 6 8 7 0] )&quot;, :offset 38, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(filter #(not= 0 %) [1 2 3 4 5 6 8 7 0] )&quot;, :offset 41, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn solvable2 [x]\n  (let [removed-zero (into [] (filter #(not= 0 %) x))]\n    (loop [counts [] xs removed-zero]\n      (if (seq xs)\n        (let [head (first xs)\n              tail (rest xs)\n              counter (fn [accum curr] (if (&gt; curr head) (inc accum) accum))]\n          (recur (conj counts (reduce counter 0 tail)) tail))\n        counts))))&quot;, :offset 349, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(odd? (reduce + (solvable2 [1 2 3 4 5 6 8 7 0])))&quot;, :offset 49, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(odd? (reduce + (solvable2 [1 2 3 4 5 6 7 0 8])))&quot;, :offset 49, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(odd? (reduce + (solvable2 [1 2 3 4 5 6 0 7 8])))&quot;, :offset 49, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(odd? (reduce + (solvable2 [1 2 3 4 5 6 0 8 7])))&quot;, :offset 49, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(even? (reduce + (solvable2 [1 2 3 4 5 6 0 8 7])))&quot;, :offset 50, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn solvable2 [x]\n  (let [removed-zero (into [] (filter #(not= 0 %) x))]\n    (loop [counts [] xs removed-zero]\n      (if (seq xs)\n        (let [head (first xs)\n              tail (rest xs)\n              counter (fn [accum curr] (if (&gt; curr head) (inc accum) accum))]\n          (recur (conj counts (reduce counter 0 tail)) tail))\n        (even? (reduce + counts))))))&quot;, :offset 368, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(solvable2 [1 2 3 4 5 6 0 8 7] )&quot;, :offset 32, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(solvable2 [1 2 3 4 5 6 0 7 8] )&quot;, :offset 32, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(solvable? [1 2 3 4 5 6 0 7 8])&quot;, :offset 31, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(into [] (flatten [[1 2 3] [4 5 6] [[7 0 8]]]))&quot;, :offset 47, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn solvable? [x]\n  (let [removed-zero (into [] (filter #(not= 0 %) x))]\n    (loop [counts [] xs removed-zero]\n      (if (seq xs)\n        (let [head (first xs)\n              tail (rest xs)\n              counter (fn [accum curr] (if (&gt; curr head) (inc accum) accum))]\n          (recur (conj counts (reduce counter 0 tail)) tail))\n        (even? (reduce + counts))))))&quot;, :offset 368, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(ns eightpuzzzle.core\n  (:gen-class)\n  (:use eightpuzzzle.grid))\n&quot;, :offset 65, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn swap-right                                            ;;ok if reaches border/ puts nil\n  [x [i1 j1]]\n  (let [f (get-in x [i1 j1])\n        q (assoc-in x [i1 j1] (get-in x [i1 (+ 1 j1)]))\n        s (assoc-in q [i1 (+ 1 j1)] f)]\n    s))\n\n\n(defn swap-left\n  [x [i1 j1]]\n  (let [f (get-in x [i1 j1])\n        q (assoc-in x [i1 j1] (get-in x [i1 (- j1 1)]))\n        s (assoc-in q [i1 (- j1 1)] f)]\n    s))\n\n(defn swap-down\n  [x [i1 j1]]\n  (let [f (get-in x [i1 j1])\n        q (assoc-in x [i1 j1] (get-in x [(+ i1 1) j1]))\n        s (assoc-in q [(+ 1 i1) j1] f)]\n    s))\n\n(defn swap-up\n  [x [i1 j1]]\n  (let [f (get-in x [i1 j1])\n        q (assoc-in x [i1 j1] (get-in x [(- i1 1) j1]))\n        s (assoc-in q [(- i1 1) j1] f)]\n    s))&quot;, :offset 730, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn main [init]\n  (if (solvable? (into [] (flatten init)))\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        (if (or (= ideal (:vector node))\n                (&gt; i 33))\n          (:history node)\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (:history node))))\n                                  false\n                                  (swap-right (:vector node) zero))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (:history node))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (:history node))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (:history node))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n              (let [moves-cost {:right (if (or (= :right (move-reverse (last (:history node))))\n                                               (= false (:right moves)))\n                                         false\n                                         (reduce + (map count-same-with-ideal (:right moves))))\n                                :left  (if (or (= :left (move-reverse (last (:history node))))\n                                               (= false (:left moves)))\n                                         false\n                                         (reduce + (map count-same-with-ideal (:left moves))))\n                                :up    (if (or (= :up (move-reverse (last (:history node))))\n                                               (= false (:up moves)))\n                                         false\n                                         (reduce + (map count-same-with-ideal (:up moves))))\n                                :down  (if (or (= :down (move-reverse (last (:history node))))\n                                               (= false (:down moves)))\n                                         false\n                                         (reduce + (map count-same-with-ideal (:down moves))))\n                                }]\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves-cost next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})))))))))))&quot;, :offset 2694, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(count-same-with-ideal [[1 2 3] [4 5 6] [0 7 8]])&quot;, :offset 49, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(reduce + (map(count-same-with-ideal [[1 2 3] [4 5 6] [0 7 8]])))&quot;, :offset 65, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn count-same-with-ideal                                 ;;use reduce map ...\n  [v1]\n  (loop [total-matches 0\n         [next-1 &amp; more-1] v1\n         [next-2 &amp; more-2] ideal]\n    (if-not (and next-1 next-2)\n      total-matches\n      (if (= next-1 next-2)\n        (recur (inc total-matches) more-1 more-2)\n        (recur total-matches more-1 more-2)))))&quot;, :offset 354, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(reduce + (map (count-same-with-ideal [[1 2 3] [4 5 6] [0 7 8]])))&quot;, :offset 66, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn count-same-with-ideal\n  [v1 v2]\n  (let [x (loop [total-matches 0\n                 [next-1 &amp; more-1] v1\n                 [next-2 &amp; more-2] ideal]\n            (if-not (and next-1 next-2)\n              total-matches\n              (if (= next-1 next-2)\n                (recur (inc total-matches) more-1 more-2)\n                (recur total-matches more-1 more-2))))]\n    x))&quot;, :offset 376, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn count-same-with-ideal\n  [v1]\n  (let [x (loop [total-matches 0\n                 [next-1 &amp; more-1] v1\n                 [next-2 &amp; more-2] ideal]\n            (if-not (and next-1 next-2)\n              total-matches\n              (if (= next-1 next-2)\n                (recur (inc total-matches) more-1 more-2)\n                (recur total-matches more-1 more-2))))]\n    x))&quot;, :offset 373, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(reduce + (map count-same-with-ideal [[1 2 3] [4 5 6] [0 7 8]]))&quot;, :offset 64, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(reduce + (map (count-same-with-ideal [[1 2 3] [4 5 6] [0 7 8]] ideal)))&quot;, :offset 72, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(reduce + (map count-same-with-ideal [[1 2 3] [4 5 6] [0 8 7]] ))&quot;, :offset 65, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn count-same-with-ideal\n  [v]\n  (let [x (loop [total-matches 0\n                 [next-1 &amp; more-1] v\n                 [next-2 &amp; more-2] ideal]\n            (if-not (and next-1 next-2)\n              total-matches\n              (if (= next-1 next-2)\n                (recur (inc total-matches) more-1 more-2)\n                (recur total-matches more-1 more-2))))]\n    x))&quot;, :offset 371, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(reduce + (map count-same-with-ideal [[1 2 3] [4 5 6] [0 8 7]]))&quot;, :offset 64, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn count-same-with-ideal\n  [v1 v2]\n  (let [x (loop [total-matches 0\n                 [next-1 &amp; more-1] v1\n                 [next-2 &amp; more-2] v2]\n            (if-not (and next-1 next-2)\n              total-matches\n              (if (= next-1 next-2)\n                (recur (inc total-matches) more-1 more-2)\n                (recur total-matches more-1 more-2))))]\n    x))&quot;, :offset 373, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(reduce + (map count-same-with-ideal [[1 2 3] [4 5 6] [0 8 7]] ideal))&quot;, :offset 70, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn count-same-elements\n  [v1 v2]\n  (let [x (loop [total-matches 0\n                 [next-1 &amp; more-1] v1\n                 [next-2 &amp; more-2] v2]\n            (if-not (and next-1 next-2)\n              total-matches\n              (if (= next-1 next-2)\n                (recur (inc total-matches) more-1 more-2)\n                (recur total-matches more-1 more-2))))]\n    x))&quot;, :offset 371, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(reduce + (map count-same-elements [[1 2 3] [4 5 6] [0 8 7]] ideal))&quot;, :offset 68, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(ns eightpuzzzle.core\n  (:gen-class)\n  (:use eightpuzzzle.grid))&quot;, :offset 64, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? (into [] (flatten init)))\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        (if (or (= ideal (:vector node))\n                (&gt; i 33))\n          (:history node)\n\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-right (:vector node) zero))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n\n              (let [moves-cost {:right (if (= false (:right moves))\n                                         false\n                                         (reduce + (map count-same-elements (:right moves) ideal)))\n                                :left  (if (= false (:left moves))\n                                         false\n                                         (reduce + (map count-same-elements (:left moves) ideal)))\n                                :up    (if (= false (:up moves))\n                                         false\n                                         (reduce + (map count-same-elements (:up moves) ideal)))\n                                :down  (if (= false (:down moves))\n                                         false\n                                         (reduce + (map count-same-elements (:down moves) ideal)))\n                                }]\n\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves-cost next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})\n                    ))))))))))&quot;, :offset 2363, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(swap-right [[1 2 3] [4 5 6] [7 8 9]] [1 1])&quot;, :offset 44, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(def testzero {:a 3 :b [1 1]})&quot;, :offset 30, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(swap-right [[1 2 3] [4 5 6] [7 8 9]] (:b testzero))&quot;, :offset 52, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(def zeo (last (:zero zero-finder)))&quot;, :offset 36, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(last (:zero (zero-finder [[1 2 3] [4 5 6] [7 8 0]])))&quot;, :offset 54, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(:zero (zero-finder [[1 2 3] [4 5 6] [7 8 0]]))&quot;, :offset 47, :ns &quot;eightpuzzzle.grid&quot;} {:command &quot;(defn main [init]\n  (if (solvable? (into [] (flatten init)))\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        (if (or (= ideal (:vector node))\n                (&gt; i 33))\n          (:history node)\n\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (last (:history node)))))\n                                  false\n                                  (do\n                                    (println (:vector node))\n                                    (swap-right (:vector node) zero)))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n\n              (let [moves-cost {:right (if (= false (:right moves))\n                                         false\n                                         (reduce + (map count-same-elements (:right moves) ideal)))\n                                :left  (if (= false (:left moves))\n                                         false\n                                         (reduce + (map count-same-elements (:left moves) ideal)))\n                                :up    (if (= false (:up moves))\n                                         false\n                                         (reduce + (map count-same-elements (:up moves) ideal)))\n                                :down  (if (= false (:down moves))\n                                         false\n                                         (reduce + (map count-same-elements (:down moves) ideal)))\n                                }]\n\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves-cost next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})\n                    ))))))))))&quot;, :offset 2465, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? (into [] (flatten init)))\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        (println node)\n        (if (or (= ideal (:vector node))\n                (&gt; i 33))\n          (:history node)\n\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (last (:history node)))))\n                                  false\n                                  (do\n                                    (println (:vector node))\n                                    (swap-right (:vector node) zero)))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n\n              (let [moves-cost {:right (if (= false (:right moves))\n                                         false\n                                         (reduce + (map count-same-elements (:right moves) ideal)))\n                                :left  (if (= false (:left moves))\n                                         false\n                                         (reduce + (map count-same-elements (:left moves) ideal)))\n                                :up    (if (= false (:up moves))\n                                         false\n                                         (reduce + (map count-same-elements (:up moves) ideal)))\n                                :down  (if (= false (:down moves))\n                                         false\n                                         (reduce + (map count-same-elements (:down moves) ideal)))\n                                }]\n\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves-cost next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})\n                    ))))))))))&quot;, :offset 2488, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? (into [] (flatten init)))\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        (println \&quot;initial input\&quot; node)\n        (if (or (= ideal (:vector node))\n                (&gt; i 33))\n          (:history node)\n\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (last (:history node)))))\n                                  false\n                                  (do\n                                    (println \&quot;zero: \&quot; zero)\n                                    (println \&quot;in swap: \&quot; (:vector node))\n                                    (swap-right (:vector node) zero)))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n\n              (let [moves-cost {:right (if (= false (:right moves))\n                                         false\n                                         (reduce + (map count-same-elements (:right moves) ideal)))\n                                :left  (if (= false (:left moves))\n                                         false\n                                         (reduce + (map count-same-elements (:left moves) ideal)))\n                                :up    (if (= false (:up moves))\n                                         false\n                                         (reduce + (map count-same-elements (:up moves) ideal)))\n                                :down  (if (= false (:down moves))\n                                         false\n                                         (reduce + (map count-same-elements (:down moves) ideal)))\n                                }]\n\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves-cost next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})\n                    ))))))))))&quot;, :offset 2576, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? (into [] (flatten init)))\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        (println \&quot;initial input\&quot; node)\n        (if (or (= ideal (:vector node))\n                (&gt; i 33))\n          (:history node)\n\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (last (:history node)))))\n                                  false\n                                  (do\n                                    (println \&quot;zero: \&quot; zero)\n                                    (println \&quot;before swap: \&quot; (:vector node))\n                                    (swap-right (:vector node) zero)))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n\n              (let [moves-cost {:right (if (= false (:right moves))\n                                         false\n                                         (reduce + (map count-same-elements (:right moves) ideal)))\n                                :left  (if (= false (:left moves))\n                                         false\n                                         (reduce + (map count-same-elements (:left moves) ideal)))\n                                :up    (if (= false (:up moves))\n                                         false\n                                         (reduce + (map count-same-elements (:up moves) ideal)))\n                                :down  (if (= false (:down moves))\n                                         false\n                                         (reduce + (map count-same-elements (:down moves) ideal)))\n                                }]\n\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})\n                    ))))))))))&quot;, :offset 2575, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(main [[1 2 3] [4 5 6] [7 0 8]])&quot;, :offset 32, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(main [[1 2 3] [4 5 6] [0 7 8]])&quot;, :offset 32, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? (into [] (flatten init)))\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        ; (println \&quot;initial input\&quot; node)\n        (if (or (= ideal (:vector node))\n                (&gt; i 100))\n          (conj (:history node) \&quot;End\&quot;)\n\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (last (:history node)))))\n                                  false\n                                  (do\n                                    ;(println \&quot;zero: \&quot; zero)\n                                    ; (println \&quot;before swap: \&quot; (:vector node))\n                                    (swap-right (:vector node) zero)))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n\n              (let [moves-cost {:right (if (= false (:right moves))\n                                         false\n                                         (reduce + (map count-same-elements (:right moves) ideal)))\n                                :left  (if (= false (:left moves))\n                                         false\n                                         (reduce + (map count-same-elements (:left moves) ideal)))\n                                :up    (if (= false (:up moves))\n                                         false\n                                         (reduce + (map count-same-elements (:up moves) ideal)))\n                                :down  (if (= false (:down moves))\n                                         false\n                                         (reduce + (map count-same-elements (:down moves) ideal)))\n                                }]\n\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})\n                    ))))))))))&quot;, :offset 2594, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? (into [] (flatten init)))\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        ; (println \&quot;initial input\&quot; node)\n        (if (or (= ideal (:vector node))\n                (&gt; i 1000))\n          (conj (:history node) \&quot;End\&quot;)\n\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (last (:history node)))))\n                                  false\n                                  (do\n                                    ;(println \&quot;zero: \&quot; zero)\n                                    ; (println \&quot;before swap: \&quot; (:vector node))\n                                    (swap-right (:vector node) zero)))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n\n              (let [moves-cost {:right (if (= false (:right moves))\n                                         false\n                                         (reduce + (map count-same-elements (:right moves) ideal)))\n                                :left  (if (= false (:left moves))\n                                         false\n                                         (reduce + (map count-same-elements (:left moves) ideal)))\n                                :up    (if (= false (:up moves))\n                                         false\n                                         (reduce + (map count-same-elements (:up moves) ideal)))\n                                :down  (if (= false (:down moves))\n                                         false\n                                         (reduce + (map count-same-elements (:down moves) ideal)))\n                                }]\n\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})\n                    ))))))))))&quot;, :offset 2595, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? (into [] (flatten init)))\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        ; (println \&quot;initial input\&quot; node)\n        (if (or (= ideal (:vector node))\n                (&gt; i 10000))\n          (conj (:history node) \&quot;End\&quot;)\n\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (last (:history node)))))\n                                  false\n                                  (do\n                                    ;(println \&quot;zero: \&quot; zero)\n                                    ; (println \&quot;before swap: \&quot; (:vector node))\n                                    (swap-right (:vector node) zero)))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n\n              (let [moves-cost {:right (if (= false (:right moves))\n                                         false\n                                         (reduce + (map count-same-elements (:right moves) ideal)))\n                                :left  (if (= false (:left moves))\n                                         false\n                                         (reduce + (map count-same-elements (:left moves) ideal)))\n                                :up    (if (= false (:up moves))\n                                         false\n                                         (reduce + (map count-same-elements (:up moves) ideal)))\n                                :down  (if (= false (:down moves))\n                                         false\n                                         (reduce + (map count-same-elements (:down moves) ideal)))\n                                }]\n\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})\n                    ))))))))))&quot;, :offset 2596, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(defn main [init]\n  (if (solvable? (into [] (flatten init)))\n    (let [input {:vector init :history []}]\n      (loop [i 0 node input]\n        ; (println \&quot;initial input\&quot; node)\n        (if (or (= ideal (:vector node))\n                (&gt; i 100000))\n          (conj (:history node) \&quot;End\&quot;)\n\n          (let [zero (:zero (zero-finder (:vector node)))]\n            (let [moves {:right (if (or (= 2 (last zero)) (= :right (move-reverse (last (:history node)))))\n                                  false\n                                  (do\n                                    ;(println \&quot;zero: \&quot; zero)\n                                    ; (println \&quot;before swap: \&quot; (:vector node))\n                                    (swap-right (:vector node) zero)))\n                         :left  (if (or (= 0 (last zero)) (= :left (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-left (:vector node) zero))\n                         :up    (if (or (= 0 (first zero)) (= :up (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-up (:vector node) zero))\n                         :down  (if (or (= 2 (first zero)) (= :down (move-reverse (last (:history node)))))\n                                  false\n                                  (swap-down (:vector node) zero))\n                         }]\n\n              (let [moves-cost {:right (if (= false (:right moves))\n                                         false\n                                         (reduce + (map count-same-elements (:right moves) ideal)))\n                                :left  (if (= false (:left moves))\n                                         false\n                                         (reduce + (map count-same-elements (:left moves) ideal)))\n                                :up    (if (= false (:up moves))\n                                         false\n                                         (reduce + (map count-same-elements (:up moves) ideal)))\n                                :down  (if (= false (:down moves))\n                                         false\n                                         (reduce + (map count-same-elements (:down moves) ideal)))\n                                }]\n\n                (let [next-node-key (key (apply max-key val (filter-false-val moves-cost)))]\n                  (let [next-node-vector (get moves next-node-key)]\n                    (recur (inc i) {:vector next-node-vector :history (conj (:history node) next-node-key)})\n                    ))))))))))&quot;, :offset 2597, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;(main [[2 3 4] [1 5 0] [7 6 8]])&quot;, :offset 32, :ns &quot;eightpuzzzle.core&quot;} {:command &quot;\&quot;hoi\&quot;&quot;, :offset 5, :ns &quot;eightpuzzzle.core&quot;}], :remote []}}</component>
  <component name="RunManager">
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="SOCKET" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration name="eightpzl" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="eightpuzzzle" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="73f5f1ee-b41e-4ef2-8e37-759a5ab5d8b9" name="Default Changelist" comment="" />
      <created>1592588367246</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1592588367246</updated>
      <workItem from="1592588369740" duration="32630000" />
    </task>
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="WindowStateProjectService">
    <state x="414" y="175" key="#com.intellij.execution.impl.EditConfigurationsDialog" timestamp="1592588410001">
      <screen x="0" y="0" width="1920" height="1040" />
    </state>
    <state x="414" y="175" key="#com.intellij.execution.impl.EditConfigurationsDialog/0.0.1920.1040@0.0.1920.1040" timestamp="1592588410001" />
    <state x="740" y="275" key="FileChooserDialogImpl" timestamp="1592726349643">
      <screen x="0" y="0" width="1920" height="1040" />
    </state>
    <state x="740" y="275" key="FileChooserDialogImpl/0.0.1920.1040@0.0.1920.1040" timestamp="1592726349643" />
  </component>
</project>